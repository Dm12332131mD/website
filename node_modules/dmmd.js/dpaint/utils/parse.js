"use strict";

/**
 * Parses a color value
 * @param {"decimal"|"hex3"|"hex"|"hsl"|"hsv"|"rgb"} t Type
 * @param  {...any} args Arguments
 * @returns {any}
 */
function parse(t, ...args) {
    if(typeof t !== "string") throw new TypeError("Argument is not a string");
    if(!args.length) throw new Error("Argument is not provided");
    switch(t.toLowerCase()) {
        case "cmyk": {
            let [ c, m, y, k ] = args;
            if([ c, m, y, k ].some(v => isNaN(v))) throw new TypeError("Argument is not a number-like value");
            let [ pc, pm, py, pk ] = [ c, m, y, k ].map(v => parseFloat(parseFloat(v).toFixed(2)));
            if([ pc, pm, py, pk ].some(v => v < 0 || v > 1)) throw new Error("Argument is not between 0 and 1");
            return { c: pc, m: pm, y: py, k: pk };
        };
        case "decimal": {
            let d = args[0];
            if(isNaN(d)) throw new TypeError("Argument is not a number-like value");
            let pd = parseInt(d);
            if(pd > 16777215 || pd < 0) throw new Error("Argument is not a valid decimal value");
            return pd;
        };
        case "hex3": {
            let m = `${args[0]}`.match(/^#?([a-z0-9]{3})$/i);
            if(m === null) throw new Error("Argument is not a valid hex value");
            return m[1];
        };
        case "hex": {
            let m = `${args[0]}`.match(/^#?([a-z0-9]{3,})$/i);
            if(m === null) throw new Error("Argument is not a valid hex value");
            let s = m[1];
            if(s.length === 3) return s.split("").map(v => v + v).join("");
            else if(s.length === 6) return s;
            else throw new Error("Argument is not a valid hex value");
        };
        case "hsl": {
            let [ h, s, l ] = args;
            if([ h, s, l ].some(v => isNaN(v))) throw new TypeError("Argument is not a number-like value");
            let ph = parseInt(h);
            let [ ps, pl ] = [ s, l ].map(v => parseFloat(parseFloat(v).toFixed(2)));
            if(ph < 0 || ph > 360) throw new Error("Argument is not between 0 and 360");
            if([ ps, pl ].some(v => v < 0 || v > 1)) throw new Error("Argument is not between 0 and 1");
            return { h: ph, s: ps, l: pl };
        };
        case "hsv": {
            let [ h, s, v ] = args;
            if([ h, s, v ].some(_v => isNaN(_v))) throw new TypeError("Argument is not a number-like value");
            let ph = parseInt(h);
            let [ ps, pv ] = [ s, v ].map(_v => parseFloat(parseFloat(_v).toFixed(2)));
            if(ph < 0 || ph > 360) throw new Error("Argument is not between 0 and 360");
            if([ ps, pv ].some(_v => _v < 0 || _v > 1)) throw new Error("Argument is not between 0 and 1");
            return { h: ph, s: ps, v: pv };
        };
        case "rgb": {
            let [ r, g, b ] = args;
            if([ r, g, b ].some(v => isNaN(v))) throw new TypeError("Argument is not a number-like value");
            let [ pr, pg, pb ] = [ r, g, b ].map(v => parseInt(v));
            if([ pr, pg, pb ].some(v => v < 0 || v > 255)) throw new Error("Argument is not between 0 and 255");
            return { r: pr, g: pg, b: pb };
        };
        default: throw new Error("Argument is not a valid type");
    };
};

// Exports
module.exports = parse;